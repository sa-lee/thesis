```{r setup}
library(superintronic)

```

# Exploratory coverage analysis with superintronic and plyranges {#ch:intron}

Here we consider a tidy-data approach for exploring
estimated coverage from RNA-seq data. We establish a simple 
framework, for aggregating across experimental design, and annotated genomic regions to discover 'interesting' coverage trace plots. We highlight how this framework can be used to
develop data descriptions that find putative genes with
intron retention. Our framework is implemented in a software
package called **superintronic**, available at https://github.com/sa-lee/superintronic.


## Introduction

In high-throughput sequencing data sets, coverage is the estimated number of
reads that overlap a single position of the reference genome, and is important for assessing sequencing data quality and used in many different aspects of omics analysis such peak-calling in ChIP-seq or variant calling in DNA-seq [@Sims2014-qk]. Here we emphasise looking at coverage traces to find biological events of interest, rather than only relying on numerical summaries of the data. By faceting these traces over combinations of the experimental design and with their biological context such as gene annotations, we can gain an
insight into biological signal under study. 
Of course, due to the sheer size of most reference genome annotations 
it would take an extremely long time for an analyst to look at every 
single possible region where there is some interesting signal within the
coverage trace. Because visualisation does not scale, we need to search the possible space of coverage traces and provide diagnostics for
identifying traces with interesting biology. We have taken inspiration from
visualisation literature; in particular the idea of scatter plot diagnostics ("scagnostics") for summarising the space of all possible 2D scatter plots
to a small number of descriptors of each scatter plots properties such as 
density or monotonicity [@Friedman2002-yx;@Wilkinson2005-xt].  Similarly,
searching for unusual time series via estimating descriptors such as seasonality or autocorrelation, and visualising those descriptors instead [@Hyndman2015-sc].

Although there are many flexible and powerful software tools, like BEDTools or DeepTools, for exploring and estimating coverage from common genomic data formats [@Quinlan2010-gc; @Ramirez2014-sh], it is advantageous to have tooling
that is tightly coupled to a statistical computing language such as R. This allows interoperability between other software packages for data wrangling, visualisation and modelling within the ecosystem of the language that may not
be possible with a single command line tool. There are also gains in reproducibility as analysts do not have to move between multiple software suites to explore their processed transcriptomics data. 

In @Lee2019-mf, we showed that there is evidence that a major
source of intron reads in RNA-seq datasets is pre-mRNA, and sought data analysis techniques to unravel different aspects of intron signal. In light of this,
we made the assumption that most intron reads do not necessarily point to
intron retention (IR) events, and developed a workflow based on combining
multiple summary statistics, "data descriptors", to find coverage traces that appear to have IR-like events by collapsing coverage scores over a design matrix alongside the exonic and intronic parts of a gene. To do this we developed a new R package called **superintronic** that provides tooling for exploratory 
coverage analysis by extending and integrating our previous software package,
**plyranges** [@Lee2019]. 

In this paper, we describe methodology for establishing data descriptors by turning coverage vectors into long form tidy data using **superintronic**
and **plyranges**. We provide a workflow below
using a zebrafish RNA-seq dataset for developing data descriptors to find IR like coverage traces within genes known to have minor class splicing events. 


## Methods

**superintronic** is an R package available on GitHub at https://github.com/sa-lee/superintronic and used for estimating, representing,
and visualising per-base coverage scores, that can then be 
flexibly summarised over factors within an experimental design and collapsed
over regions of the genome using our companion package **plyranges**. The
aspects of this combined workflow are summarised in figure \@ref(fig:si-fig). 

(ref:si-fig): An overview of the **superintronic** and **plyranges** workflow. Coverage is estimated directly using the design matrix that contains a source column pointing to the locations of BAM files. The long-form representation is output as a **GRanges** object, and contains columsns that were part of the design. Additional annotations are add with join functions, here we show the particular case of expanding the coverage **GRanges** to include exonic and intronic parts of a gene. This object can be further anlaysed using **plyranges** and our data descriptors approach, and then descriptors can be visualised as a scatter plot matrix with the `GGally` and `ggplot2` packages [@ggally; @Wickham2016-gz]. Coverage traces can be directly generated with **superintronic** and collapsed over parts of the design matrix to identify differences between groups.

```{r si-fig, fig.cap = "(ref:si-fig)", echo = FALSE}
knitr::include_graphics(here::here("img", "si-workflowflow.png"))
```

### Representation of coverage estimation

The per base coverage score is estimated directly from one or more BAM files
that represent the units within the experimental design,
along with an optional experimental design table that is returns 
a long-form tidy **GRanges** data structure. The coverage estimation is
computed via the **Rsamtools** package, and
users have the ability to estimate coverage in parallel and drop regions
in the genome where there is no coverage [@rsamtools; @GenomicRanges]. This
representation is tidy, since each row of the resulting **GRanges** data
structure corresponds to position(s) within a given sample with a given 
coverage score alongside any variables such as biological group. While the long-form representation repeats the same information
for a sample within the design, the size of the resulting **GRanges** in
memory can be compressed using run-length encoding for any categorical 
variable. This representation allows us to easily transform the coverage scores
and integrate annotations using the **plyranges** grammar, and visualise traces using **ggplot2** [@Wickham2016-gz].

### Integration of external annotations

External reference annotations, perhaps transcripts or exons, 
can be coerced to **GRanges** objects, are  incorporated into the coverage **GRanges** by taking the intersection of
the annotation with the **GRanges** using an overlap intersect join from the **plyranges** software. The resulting intersection will now contain the
per base coverage that are overlapped the genomic features in the annotation,
along side any metadata about the features themselves. Since our main workflow
interest is in discovering coverage traces with IR profiles, **superintronic**
provides some syntactic sugar for unravelling gene annotations into their exonic
and intronic parts, and intersecting them with a coverage **GRanges**.

### Discovery of regions of interest via 'data descriptors'

Once the coverage **GRanges** has reference genomic features, data 
descriptors can be computed via collecting summary statistics across
the factors of the experimental design and features of interest. This can be
achieved using **plyranges** directly by first grouping across variables
of interest, computing descriptors defined by **superintronic** and then
pivoting the results into a wide form table for additional processing or
visualisation. There are many descriptors defined by **superintronic**
that are weighted statistics (as we have to account for the number of bases
covered, or the width of the range) of the coverage score, such as the mean 
and standard deviation. There are also descriptors that can be used to find
the number of times the coverage trace is above a certain number of bases
or score. To find coverage traces that have unusual descriptors, 
the descriptors can be visualised directly as a scatter plot matrix. After that
thresholds can be applied to filter the genomic features that had extreme
descriptors on the coverage **GRanges**, and the traces can be visualised. 


## Results

### A workflow for uncovering intron retention in zebrafish


Read coverage of intronic and exonic regions were calculated for poly(A) RNA and Total RNA HCC827 human cell lines using our \textit{superintronic} package,.
Genes of interest were restricted to protein coding genes on reference chromosomes, and we removed any genes that overlapped another to simplify the analysis and reduce coverage ambiguity.  
Genes were then further filtered if they were not expressed in the poly(A) RNA protocol (requiring at least 3 reads overlapping intronic and exonic regions). 
A total of 3,262 genes were examined and categorised as short, regular or long (roughly 1,087 genes in each category) by splitting the length of each gene into three bins by tertiles. 

Using associated BAM files and GENCODE v27 annotation GTF, \textit{superintronic} summarised the number of bases covered at a given coverage score for each gene and sample.
For exonic regions and intronic regions, coverage scores were transformed to log$_2$-scale using an offset of 0.5, and then normalised by dividing by each gene and each sample's maximum log-coverage score.
Normalised log-coverage scores, or {\it relative log-coverage} (relative to each gene's maximum coverage), were divided into 20 windows along the length of each gene using the \textit{GenomicRanges} package \cite{GenomicRanges}.
To summarise coverage patterns across genes, \textit{plyranges} \cite{Lee2019plyranges} was applied to relative log-coverage scores by intersecting it with the positional windows.
Each window's mean coverage score (mean relative log-coverage) was calculated for each gene.
Based on the position of the windows, they were further summarised across genes by taking its mean. % (mean of mean relative log-coverage).  
The summary values were calculated separately for genes categorised as short, regular and long to represent general coverage trends along the gene body.

\textit{Human cell lines} of lung adenocarcinoma HCC827 and NCI-H1975 were cultured on three
separate occasions by Holik {\it et al.} (2017) \cite{Holik:NAR:2017} giving three pseudo biological replicates. 
RNA was extracted from each pseudo biological replicate and split into two and prepared as poly(A) RNA and Total RNA libraries.
Raw sequencing reads were downloaded from the Gene Expression Omnibus (GEO) \citep{GEO:2013} under accession number GSE64098.
12 libraries were examined for this dataset. 

FASTQ files containing raw sequencing reads were aligned to the human \textit{hg38} or mouse \textit{mm10}
% or {\color{blue}{zebrafish \textit{GRCz11}}} 
genome using \textit{subjunc} \citep{Liao:NAR:2013} with default parameters in the \textit{Rsubread} software package \citep{Rsubread:2019}. 
GENCODE's main \textit{Comprehensive gene annotation} file in GTF format was downloaded from {https://www.gencodegenes.org} for human (Release 27) and mouse (Release M12). 
Using ``gene types'' (rather than ``transcript types'') from Gencode, the annotation files were simplified by taking the union of two or more overlapping exons from transcripts of the same gene.
The adjustment provides a simplification of genomic positions on each strand, such that each position is classified as belonging to ``exon'', ``intron'' or otherwise outside of an annotated gene.
Three resultant annotation files were saved in standard annotation format (SAF) -- exon annotation, intron annotation (region between exons), and genebody annotation (region spanning first to last exon).
Our Supplementary Materials available at \href{https://github.com/charitylaw/Intron-reads}{https://github.com/charitylaw/Intron-reads} contain the scripts to process annotation files, together with other data analyses and supplementary figures. 





\subsection{\textit{Superintronic} finds genes with IR-like coverage profiles in human cell lines}

\begin{figure*}[!tpb]
\centerline{\includegraphics[width=\textwidth]{coverage-si-hits.pdf}}
\caption{{\it Superintronic} selects genes with IR-like coverage profiles in poly(A) RNA HCC827 cell lines. Genes (a) PSMB7, (b) EIF2S3, and (c) ARGLU1 are highlighted out of 43 genes selected. Whilst the analysis was carried out on poly(A) RNA libraries, coverage is shown for both poly(A) RNA HCC827 (top) and Total RNA HCC827 (bottom) samples to ensure that results are not an artefact of RNA library preparation. Coverage is oriented from 5' to 3', with exon regions coloured green and intron regions coloured orange.
}\label{fig:ir}
\end{figure*}


Using \textit{superintronic}, poly(A) RNA HCC827 cell lines were examined for genes with IR  after selecting genes in the hg38 reference that were protein coding, did not overlap any other gene and were placed on the main configs -- a total of 6,606 genes. 
These genes were then split into intron and exon regions and intersected with the coverage of each sample. 
Per gene intron and exon summary statistics, mean and standard deviation, were computed on log-coverage values. 
We selected genes enriched for IR-like coverage profiles by looking for ``expressed'' genes, where for a substantial number of intron bases its coverage is much higher than other intron features within the same gene while having similar expression levels to the exon features. 
To do this we used the following thresholds -- genes had an average exon log-coverage of greater than 2 (corresponding to the mean of average exon log-coverage values across all genes), a standard deviation of intron log-coverage greater than 1.5 (corresponding to the mean of intron standard deviation values across all genes), and genes with a large number of intron bases with log-coverage greater than 2 (top 1\% of genes).
The thresholds were chosen after examining distributions of the summary statistics (Supplementary Figure 4).
Forty-three genes met these criteria, where a manual check of coverage profiles revealed that 36 genes indeed appear IR-like (see `Analyses' page in Supplementary Materials).
We highlight 3 of these genes in Figure~\ref{fig:ir}.
The coverage of remaining 7 genes appear to be more pre-mRNA-like, with large 
variation in intron coverage, where at its peak it is expressed similarly to exon features. 

We use poly(A) RNA samples in our analysis for consistency with previous studies on IR.
In theory, Total RNA samples may be more appropriate for this exercise since it is less biased towards the 3' end, where high 3' intron coverage as a result of 3' bias in poly(A) RNA libraries can be mistaken as a 3' retained intron. 
For this reason, we review both the coverage of poly(A) RNA and Total RNA samples in  our \textcolor{red}{S}upplementary \textcolor{red}{M}aterials for all selected genes to ensure that retained introns found in poly(A) RNA samples are not an artifact of RNA library preparation. 

If differentially retained introns are of interest, one could simply run \textit{superintronic} on two conditions separately and compare lists of IR-like genes between groups.
We found that differences between the lists of IR-like genes were concordant with \textit{index} results for genes DE by intron counts, as expected (see `Analyses' page in Supplementary Materials).
For example, 14 genes were uniquely selected as IR-like in Total RNA HCC827 cell line when compared to Total RNA NCI-H1975 cell line using \textit{superintronic}, where 13 of those genes were also found to be DE in intron counts by \textit{index}, and in the expected direction.
Similarly, 19 genes were uniquely detected as IR-like in Total RNA NCI-H1975 by \textit{superintronic}, 16 of which were also detected as DE in intron counts by \textit{index}.
Additionally, 12 genes which were found to be IR-like in both cell lines appear to have varying intron expression according to \textit{index} since it is found to be DE in intron counts. 

\textcolor{red}{
Whilst genes that are uniquely IR-like were concordant with directional changes in intron counts, we did not find that IR-like genes played a large part in \textit{index} gene categorisation.
This was mostly expected since thousands of genes were detected as significantly DE by \textit{index} and a relatively small number of genes were detected as IR-like by \textit{superintronic}.
Specifically, IR-like genes did not overlap with one particular \textit{index} category (see `Analyses' page in Supplementary Materials).
Of genes that are classified as intron+ or intron-, only 3 out of 1,006 genes were also detected by \textit{superintronic} as IR-like.
In the ``mixed'' category, 2 out of 54 genes were also detected as IR-like.
}

## Discussion


## Conclusion


<!-- ## Data -->

<!-- We will use data from 12 samples from the human cell line mixture RNA-seq -->
<!-- data. There are three biological replicates across two library preparation kits, -->
<!-- a polyA kit and a total RNA kit. The BAM files have been previously aligned -->
<!-- with subread using the hg20 reference genome.  -->

<!-- ```{r prepare-design, echo= FALSE} -->
<!-- design <- readRDS(here("data", "superintronic", "design.rds")) -->
<!-- ``` -->


<!-- ## `superintronic` analysis -->

<!-- A superintronic analysis consists of four steps: -->
<!-- 1. Preparing the annotation and extract exonic/intronic parts -->
<!-- 2. Computing coverage over regions of interest -->
<!-- 3. Summarising coverage over regions of interest -->
<!-- 4. Visualising the results -->

<!-- Steps 1 and 2. are performed in the `scripts/run_coverage.R` -->

<!-- ### Preparing GFF/GTF files -->

<!-- ```{r gff} -->
<!-- library(superintronic) -->
<!-- parts <- readRDS(here::here("data", "complete-annotation.rds")) -->
<!-- parts -->
<!-- ``` -->

<!-- These can be interrogated as desired, but for our purposes we will keep -->
<!-- genes that are protein coding, on main chromosomes but not mitochondrial  -->
<!-- genome, and do not overlap any other genes and have more than one exon. -->

<!-- ```{r default-filter, echo = FALSE} -->
<!-- parts_sub <- readRDS(here::here("data", "filtered-annotation.rds")) -->
<!-- parts_sub -->
<!-- ``` -->


<!-- ## Coverage over intronic/exonic regions -->

<!-- Now all the ingredients are in place to merge the coverage scores -->
<!-- to our prepared annotation with `join_parts()`. This again -->
<!-- returns a GRanges object, restricted to the intersection of the  -->
<!-- coverage ranges with intron/exon ranges. Additional columns are added -->
<!-- corresponding to the properties of the intron/exon. -->


<!-- ```{r, load-features, echo = FALSE } -->
<!-- cvg_over_features <- readRDS(here::here("data", "parts-coverage.rds")) -->
<!-- ``` -->

<!-- Now we will compute summaries for each cell line and kit to detect IR  -->
<!-- genes. This consists of three steps -->

<!-- 1. Computing the average log-coverage over all exon/intron features: -->

<!-- ```{r rangenostics-01} -->
<!-- # compute intron/exon features -->
<!-- cvg_over_features <- cvg_over_features %>%  -->
<!--   mutate(log_score = log2(score + 0.5))   -->

<!-- cvg_by_features <- cvg_over_features %>%  -->
<!--   group_by(Kit, CellLine, gene_id, feature_type) -->
<!-- E_vals <- cvg_by_features %>%  -->
<!--   summarise(mn = Hmisc::wtd.mean(log_score, width), -->
<!--             sd = sqrt(Hmisc::wtd.var(log_score, width)), -->
<!--             raw_mn = Hmisc::wtd.mean(score, width), -->
<!--             score = score, -->
<!--             n_bases = width, -->
<!--             start = min(start), -->
<!--             end = max(end), -->
<!--             seqnames = unlist(unique(seqnames)), -->
<!--             strand = unlist(unique(feature_strand))) %>%  -->
<!--   makeGRangesFromDataFrame(keep.extra.columns = TRUE) -->
<!-- ``` -->


<!-- 2. For exon features computing the mean and variance of average log-coverage  -->
<!--    over all genes (lumpiness). -->

<!-- ```{r rangenostics-02} -->
<!-- lumpy <- E_vals %>%  -->
<!--   filter(sd > 0, feature_type == "exon") %>%  -->
<!--   group_by(Kit, CellLine) %>%  -->
<!--   summarise( -->
<!--     E_mu = mean(mn), -->
<!--     E_sd = mean(sd), -->
<!--     E_raw = mean(raw_mn) -->
<!-- ) -->
<!-- lumpy  -->
<!-- mcols(E_vals) <- cbind(mcols(E_vals), -->
<!--                        lumpy[match(paste0(E_vals$Kit, E_vals$CellLine),  -->
<!--                                    paste0(lumpy$Kit, lumpy$CellLine)), -c(1,2)]) -->
<!-- E_vals <- E_vals %>%  -->
<!--   mutate( -->
<!--     n_bases_E_raw = sum(n_bases[score > E_raw]), -->
<!--   )  -->
<!-- ``` -->


<!-- 3. Compute the average number of bases with a  -->
<!--    log-coverage score above the E values defined above. We have also computed -->
<!--    a smooth between over the intron/exon feature standard deviation against -->
<!--    the average for visualisation purposes. -->

<!-- ```{r rangenostics-03} -->
<!-- rango <- E_vals %>%  -->
<!--   plyranges::select(-n_bases, -score, -seqnames, -start, -end, -width, -strand,  -->
<!--          .drop_ranges = TRUE) %>%  -->
<!--   dplyr::as_tibble() %>%  -->
<!--   group_by(Kit, CellLine, feature_type) %>%  -->
<!--   tidyr::nest() %>%  -->
<!--   mutate( -->
<!--     smooth = lapply(data, function(x) { -->
<!--       mgcv::gam(sd ~ s(mn), data = x) -->
<!--       }), -->
<!--     augment = lapply(smooth, broom::augment), -->
<!--   ) %>%  -->
<!--   tidyr::unnest(data, augment) %>%  -->
<!--   dplyr::select(-dplyr::ends_with("1"), -.sigma) -->
<!-- ``` -->

<!-- 4. Plot the results. -->

<!-- We get very similar results to a `voom` plot in a standard limma analysis. We -->
<!-- have also overlaid on the E_mu and E_sigma values as potential cut-offs for -->
<!-- each feature.  -->

<!-- ```{r voom-like-plot} -->
<!-- # rangenostics feature_average vs feature_sd coloured by n of bases above -->
<!-- # average raw exon coverage -->
<!-- library(ggplot2) -->
<!-- voom_plot <- function(.x, .y) { -->
<!--   p <- ggplot(data = .x, aes(x = mn, y = sd)) + -->
<!--     geom_point() + -->
<!--     geom_line(aes(y = .fitted), colour = "blue") + -->
<!--     geom_vline(aes(xintercept = E_mu),  -->
<!--                data  = dplyr::distinct(.x, feature_type, E_mu)) + -->
<!--     geom_hline(aes(yintercept = E_sd), -->
<!--                data = dplyr::distinct(.x, feature_type, E_sd)) + -->
<!--     facet_wrap(~feature_type) + -->
<!--     labs( -->
<!--          subtitle = paste(.y$Kit, .y$CellLine), -->
<!--          x = "mean log-coverage", -->
<!--          y = "sd log-covreage" -->
<!--     ) -->
<!--   fname <- here::here("img",  -->
<!--                       paste0(.y$Kit, "-", .y$CellLine,  -->
<!--                              "voom-like-plot.png") -->
<!--   ) -->
<!--   ggsave(fname, p) -->
<!-- } -->
<!-- rango %>%  -->
<!--   group_by(Kit, CellLine) %>%  -->
<!--   dplyr::group_walk(voom_plot) -->
<!-- ``` -->

<!-- We also plot pairs of summary values for each feature in a scatter plot matrix -->
<!-- (using a hexbin scatter plot). Again we get similar results to the plots -->
<!-- produced by a DE analysis from InDeX. -->

<!-- ```{r rangenostics-pairs} -->
<!-- all_features <- tidyr::gather(rango, "key", "value",  -->
<!--                               -Kit, -CellLine, -gene_id, -feature_type,  -->
<!--                               -E_mu, -E_sd, -E_raw) %>%  -->
<!--   mutate(var = paste0(feature_type, "_", key)) %>%  -->
<!--   plyranges::select(-feature_type, -key) %>%  -->
<!--   arrange(gene_id) %>%  -->
<!--   tidyr::spread(var, value) -->
<!-- pairs_plot <- function(.x, .y) { -->
<!--   sub <- plyranges::select(.x,  -->
<!--                            exon_mn,  -->
<!--                            intron_mn,  -->
<!--                            intron_sd,  -->
<!--                            bases_above = intron_n_bases_E_raw) -->
<!--   fname <- here::here("img",  -->
<!--                       paste0(.y$Kit, "-", .y$CellLine,  -->
<!--                              "-pairs-plot.png") -->
<!--   ) -->

<!--   p <- GGally::ggpairs(sub, columns = 1:4, lower = list(continuous = hex)) -->
<!--   ggsave(fname, p) -->
<!-- } -->
<!-- all_features %>%  -->
<!--   group_by(Kit, CellLine) %>%  -->
<!--   dplyr::group_walk(pairs_plot) -->


<!-- ``` -->

<!-- 5. Decide on cut-off over each feature. It appears that choosing genes -->
<!-- with high intron feature standard deviations, and with number of bases above -->
<!-- E_mu in the 99th percentile discriminates intron retention features well. -->

<!-- ```{r rangenositcs-hits} -->
<!-- hits <- all_features %>%  -->
<!--   group_by(Kit, CellLine) %>%  -->
<!--   filter(exon_mn > E_mu,  -->
<!--          intron_sd > E_sd,  -->
<!--          intron_n_bases_E_raw > quantile(intron_n_bases_E_raw, 0.99))   -->

<!-- dplyr::count(hits) -->
<!-- ``` -->

<!-- 6. We can also look at overlaps between sets using an UpSet plot: -->

<!-- ```{r, echo  = FALSE} -->
<!-- sets <- hits %>%  -->
<!--   dplyr::distinct(gene_id) %>% -->
<!--   arrange(gene_id) %>%  -->
<!--   mutate(value = 1L, var = paste(CellLine, Kit)) %>%  -->
<!--   ungroup() %>%   -->
<!--   plyranges::select(gene_id, var, value) %>%  -->
<!--   tidyr::spread(var, value) %>%  -->
<!--   dplyr::mutate_at(2:5, .funs = ~ dplyr::if_else(is.na(.), 0L, .))  -->
<!-- sets <- as.data.frame(sets) -->
<!-- library(UpSetR) -->
<!-- pdf(here::here("img", "olaps-superintronic-hits.pdf")) -->
<!-- upset(sets) -->
<!-- dev.off() -->
<!-- ``` -->
